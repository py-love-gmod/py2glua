from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Set

from ...py.py_ir_dataclass import (
    PyIRCall,
    PyIRComment,
    PyIRConstant,
    PyIRContext,
    PyIRFile,
    PyIRIf,
    PyIRVarUse,
)
from ..compile_exception import CompileError
from ..compiler import Compiler


class BuildEntryFilePass:
    def __init__(self, project_name: str, author_name: str):
        self.project = project_name
        self.author = author_name

    def run(self, project: list[PyIRFile], compiler: Compiler) -> list[PyIRFile]:
        deps = self._build_dep_graph(project)
        sorted_files = self._toposort(deps, project)

        for f, used in deps.items():
            from_realm = self._get_realm(f)
            if from_realm == "CLIENT":
                for t in used:
                    to_realm = self._get_realm(t)
                    if to_realm == "SERVER":
                        from_name = self._get_module_name(f) or str(f.path)
                        to_name = self._get_module_name(t) or str(t.path)
                        raise CompileError(
                            f"Клиентский модуль '{from_name}' не может импортировать серверный модуль '{to_name}'"
                        )

        shared_files: List[PyIRFile] = []
        server_files: List[PyIRFile] = []
        client_files: List[PyIRFile] = []

        for f in sorted_files:
            realm = self._get_realm(f)
            if realm == "SERVER":
                server_files.append(f)

            elif realm == "CLIENT":
                client_files.append(f)

            else:
                shared_files.append(f)

        body = []

        header = [
            PyIRComment(0, 0, "This file was automatically generated by py2glua"),
            PyIRComment(0, 0, "GitHub: https://github.com/py-love-gmod/py2glua"),
            PyIRComment(0, 0, f"Project: {self.project}"),
            PyIRComment(0, 0, f"Author: {self.author}"),
            PyIRComment(0, 0, f"Tool version: {compiler.version}"),
            PyIRComment(0, 0, "Do not edit this file manually"),
        ]
        body.extend(header)

        def make_call(name: str, value: str) -> PyIRCall:
            return PyIRCall(
                0,
                0,
                name=name,
                args_p=[PyIRConstant(0, 0, value)],
                args_kw={},
            )

        def make_require(f: PyIRFile) -> PyIRCall:
            return make_call("require", f.path.stem)  # pyright: ignore[reportOptionalMemberAccess]

        def make_send(f: PyIRFile) -> PyIRCall:
            return make_call("AddCSLuaFile", f"{f.path.stem}.lua")  # pyright: ignore[reportOptionalMemberAccess]

        server_then = []
        for f in (*client_files, *shared_files):
            server_then.append(make_send(f))

        for f in server_files:
            server_then.append(make_require(f))

        client_else = []
        for f in client_files:
            client_else.append(make_require(f))

        if server_then or client_else:
            body.append(
                PyIRIf(0, 0, PyIRVarUse(0, 0, "SERVER"), server_then, client_else)
            )

        for f in shared_files:
            body.append(make_require(f))

        init_ir = PyIRFile(
            line=0,
            offset=0,
            path=Path("lua") / "autorun" / f"{self.project}_{self.author}_init.py",
            body=body,
            context=PyIRContext(meta={}, scope_name=set()),
        )

        project.append(init_ir)
        return project

    def _get_realm(self, f: PyIRFile) -> str:
        realm = None
        if f.context is not None:
            realm = f.context.meta.get("realm")

        if realm is None:
            return "SHARED"

        if isinstance(realm, str):
            name = realm.upper()

        elif hasattr(realm, "name"):
            name = str(realm.name).upper()

        else:
            name = str(realm).upper()

        if "CLIENT" in name:
            return "CLIENT"

        if "SERVER" in name:
            return "SERVER"

        return "SHARED"

    def _get_module_name(self, f: PyIRFile) -> str | None:
        if f.context is not None:
            mod = f.context.meta.get("module")
            if isinstance(mod, str) and mod:
                return mod

        if f.path is None:
            return None

        p = f.path.with_suffix("")
        if not p.parts:
            return None

        return ".".join(p.parts)

    def _build_dep_graph(
        self, project: list[PyIRFile]
    ) -> Dict[PyIRFile, Set[PyIRFile]]:
        deps: Dict[PyIRFile, Set[PyIRFile]] = {}

        module_index: Dict[str, PyIRFile] = {}
        for f in project:
            deps[f] = set()
            name = self._get_module_name(f)
            if name:
                module_index[name] = f

        for f in project:
            imports = []
            if f.context is not None:
                imports = f.context.meta.get("imports", [])

            for mod in imports:
                if not isinstance(mod, str):
                    continue

                target = self._resolve_import_name(module_index, mod)
                if target is not None and target is not f:
                    deps[f].add(target)

        return deps

    def _resolve_import_name(
        self,
        module_index: Dict[str, PyIRFile],
        mod: str,
    ) -> PyIRFile | None:
        candidate = mod
        while True:
            if candidate in module_index:
                return module_index[candidate]

            if "." not in candidate:
                break

            candidate = candidate.rsplit(".", 1)[0]

        return None

    def _toposort(
        self,
        deps: Dict[PyIRFile, Set[PyIRFile]],
        project_order: list[PyIRFile],
    ) -> List[PyIRFile]:
        order_index: Dict[PyIRFile, int] = {f: i for i, f in enumerate(project_order)}

        result: List[PyIRFile] = []
        temp: Set[PyIRFile] = set()
        perm: Set[PyIRFile] = set()

        def visit(n: PyIRFile) -> None:
            if n in perm:
                return
            if n in temp:
                raise CompileError(f"Циклический импорт: {n.path}")

            temp.add(n)

            children = sorted(deps[n], key=lambda x: order_index.get(x, 0))
            for d in children:
                visit(d)

            temp.remove(n)
            perm.add(n)
            result.append(n)

        for f in project_order:
            visit(f)

        return result

    @staticmethod
    def _iter_unique(files: List[PyIRFile]):
        seen: Set[PyIRFile] = set()
        for f in files:
            if f in seen:
                continue

            seen.add(f)
            yield f
