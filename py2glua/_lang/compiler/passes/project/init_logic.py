from __future__ import annotations

from pathlib import Path
from typing import Final

from .....config import Py2GluaConfig
from ....py.ir_dataclass import (
    FileRealm,
    PyIRComment,
    PyIREmitExpr,
    PyIREmitKind,
    PyIRFile,
    PyIRNode,
)
from ..analysis.symlinks import SymLinkContext


class BuildAutorunInitProjectPass:
    """
    Project-pass: builds an autorun init PyIRFile at an imaginary path:
        lua/autorun/init.py

    Init (minimal context switches):
      - warning comments
      - NameSpace = {}
      - NameSpace.None proxy
      - one SERVER block AddCSLuaFile(...)
      - one SERVER block include(...)
      - one CLIENT block include(...)
    """

    _INIT_VIRTUAL_PATH: Final[Path] = Path("lua") / "autorun" / "init.py"

    @classmethod
    def run(cls, files: list[PyIRFile], ctx: SymLinkContext) -> list[PyIRFile]:
        ns = (Py2GluaConfig.namespace or "").strip()
        if not ns:
            raise AssertionError(
                "Py2GluaConfig.namespace is empty; cannot build autorun init."
            )

        ctx.ensure_module_index()
        cls._add_resolved_path_aliases(ctx)

        mod_to_ir: dict[str, PyIRFile] = {}
        mod_to_inc: dict[str, str] = {}

        for ir in files:
            if ir.path is None:
                continue

            if ir.path.as_posix() == cls._INIT_VIRTUAL_PATH.as_posix():
                continue

            mod = cls._module_of_path(ir.path, ctx)
            if not mod:
                continue

            inc = cls._include_path_from_source(ir.path, mod=mod)
            if inc.startswith("autorun/"):
                continue

            mod_to_ir[mod] = ir
            mod_to_inc[mod] = inc

        deps: dict[str, set[str]] = getattr(ctx, "project_deps", {}) or {}
        ordered = cls._order_modules(
            mod_to_ir.keys(),  # type: ignore
            deps,
        )

        addscluafile: list[str] = []
        server_includes: list[str] = []
        client_includes: list[str] = []

        for mod in ordered:
            ir = mod_to_ir[mod]
            inc = mod_to_inc[mod]
            r = ir.realm

            # Send to clients: SHARED/CLIENT/MENU
            if r in (FileRealm.SHARED, FileRealm.CLIENT, FileRealm.MENU):
                addscluafile.append(inc)

            # Include on server: SERVER/SHARED
            if r in (FileRealm.SHARED, FileRealm.SERVER):
                server_includes.append(inc)

            # Include on client: SHARED/CLIENT/MENU (MENU treated as CLIENT)
            if r in (FileRealm.SHARED, FileRealm.CLIENT, FileRealm.MENU):
                client_includes.append(inc)

        init_ir = PyIRFile(
            line=None,
            offset=None,
            path=cls._INIT_VIRTUAL_PATH,
            body=cls._build_init_body(
                ns=ns,
                addscluafile=addscluafile,
                server_includes=server_includes,
                client_includes=client_includes,
            ),
            imports=[],
            realm=FileRealm.SHARED,
        )

        out: list[PyIRFile] = [init_ir]
        for ir in files:
            if (
                ir.path is not None
                and ir.path.as_posix() == cls._INIT_VIRTUAL_PATH.as_posix()
            ):
                continue

            out.append(ir)

        return out

    @classmethod
    def _build_init_body(
        cls,
        *,
        ns: str,
        addscluafile: list[str],
        server_includes: list[str],
        client_includes: list[str],
    ) -> list[PyIRNode]:
        out: list[PyIRNode] = []

        for text in [
            "=" * 60,
            "AUTO-GENERATED BY py2glua. DO NOT EDIT THIS ADDON!",
            "This addon is fully generated from Python sources.",
            "github: https://github.com/py-love-gmod/py2glua",
            f"py2glua version: {Py2GluaConfig.version()}",
            f"debug build: {Py2GluaConfig.debug}",
            "=" * 60,
        ]:
            out.append(PyIRComment(line=None, offset=None, value=text))

        out.append(PyIRComment(line=None, offset=None, value="Init ns and none proxy"))
        out.append(cls._raw(f"{ns} = {{}}"))
        out.append(
            cls._raw(
                f'{ns}.None = setmetatable({{}}, {{ __tostring = function() return "None" end }})'
            )
        )
        out.append(cls._blank())

        out.append(PyIRComment(line=None, offset=None, value="Auto load blob"))
        if addscluafile:
            out.append(PyIRComment(line=None, offset=None, value="Transport"))
            out.append(cls._raw("if SERVER then"))
            for p in addscluafile:
                out.append(cls._raw(f"    AddCSLuaFile({cls._q(p)})"))

            out.append(cls._raw("end"))

        out.append(PyIRComment(line=None, offset=None, value="Execution"))
        if server_includes:
            out.append(cls._raw("if SERVER then"))
            for p in server_includes:
                out.append(cls._raw(f"    include({cls._q(p)})"))

            out.append(cls._raw("end"))

        if client_includes:
            out.append(cls._raw("if CLIENT then"))
            for p in client_includes:
                out.append(cls._raw(f"    include({cls._q(p)})"))

            out.append(cls._raw("end"))

        return out

    @staticmethod
    def _raw(s: str) -> PyIREmitExpr:
        return PyIREmitExpr(line=None, offset=None, kind=PyIREmitKind.RAW, name=s)

    @staticmethod
    def _blank() -> PyIREmitExpr:
        return PyIREmitExpr(line=None, offset=None, kind=PyIREmitKind.RAW, name="")

    @staticmethod
    def _q(p: str) -> str:
        s = p.replace("\\", "/").replace('"', '\\"')
        return f'"{s}"'

    @classmethod
    def _order_modules(
        cls, modules: set[str] | list[str], deps: dict[str, set[str]]
    ) -> list[str]:
        mod_set = set(modules)
        memo: dict[str, int] = {}

        def depth(m: str) -> int:
            if m in memo:
                return memo[m]
            d = 0
            for dep in deps.get(m, set()):
                if dep not in mod_set:
                    continue
                d = max(d, 1 + depth(dep))
            memo[m] = d
            return d

        items = [(depth(m), m) for m in mod_set]
        items.sort(key=lambda t: (t[0], t[1]))
        return [m for _, m in items]

    @classmethod
    def _include_path_from_source(cls, src_path: Path, *, mod: str) -> str:
        """
        include() path must be relative to lua/ directory.
        We mirror source layout under lua/ and swap suffix to .lua.
        If the mirrored rel starts with 'lua/', strip it to avoid lua/lua/ duplication.
        """
        try:
            src_root = Py2GluaConfig.source.resolve()
            rel = src_path.resolve().relative_to(src_root)

            if rel.parts and rel.parts[0] == "lua":
                rel = rel.relative_to("lua")

            return rel.with_suffix(".lua").as_posix()

        except Exception:
            return (Path(*mod.split("."))).with_suffix(".lua").as_posix()

    @classmethod
    def _add_resolved_path_aliases(cls, ctx: SymLinkContext) -> None:
        add: dict[Path, str] = {}
        for p, mod in list(ctx.module_name_by_path.items()):
            try:
                pr = p.resolve()
            except Exception:
                continue

            if pr not in ctx.module_name_by_path:
                add[pr] = mod

        if add:
            ctx.module_name_by_path.update(add)

    @staticmethod
    def _module_of_path(p: Path, ctx: SymLinkContext) -> str | None:
        hit = ctx.module_name_by_path.get(p)
        if hit is not None:
            return hit
        try:
            pr = p.resolve()

        except Exception:
            return None

        return ctx.module_name_by_path.get(pr)
